---
title: "Making a diagram from a **modelbuilder** object"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{making-a-diagram}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(modeldiagram)
```

# Introduction

## Typical workflow
We anticipate the typical workflow to look something like this:

```{r workflow, eval = FALSE}
dfs <- make_dataframes(input_list = my_model_str)
diagram_plot <- make_diagram(df_list = dfs)
ggplot_code <- write_diagram_code(df_list = dfs)

# print the plot to screen
diagram_plot

# write the code to the console
cat(ggplot_code)
```

where `my_model_str` is an appropriate listed model structure (see below).
The package functions and their outputs are described in detail below.

## Input structure

The first step to making a diagram is to have a dynamic model encoded in an appropriate structure.
The **modeldiagram** package was developed to work well with the **modelbuilder** package structure for dynamic models.
We will use a **modelbuilder** object for demonstration here.
The object is called `mbsir`, which is part of the **modeldiagram** package and is a **modelbuilder** list object representing a Susceptible, Infected, Recovered (SIR) disease transmission model.

The `mbsir` object is a list of lists:

```{r mbsir-look}
str(mbsir, max.level = 1)
```

The most important aspects are the variables `mbsir[["var"]]` and the parameters `mbsir[["par"]]`.
The variables list contains the flows into (with "+" sign) and out of (with "-" sign) the variable.
For example, here is the `S` variable information:

```{r svar}
mbsir[["var"]][[1]]
```

From this information, we can see that there are no flows into the `S` variable, only out: ```r mbsir[["var"]][[1]]$flows```.

## Data frames for the diagram
**modeldiagram** generates data frames from the model structure that will be used in **ggplot2** to construct the diagram.
Five (5) data frames are produced based on the model structure:

1. `nodes`: a data frame with four columns
    * `id`: the node (variable) id number, used to match with the edge data frames
    * `label`: the label of the node (variable), e.g. "S" for susceptible
    * `x`: the x position of the node box
    * `y`: the y position of the node box
1. `horizontal_edges`: a data frame with 9 columns
    * `to`: the `id` of the node *to which* the flow terminates (e.g., arrow points toward this node)
    * `from`: the `id` of the node *from which* the flow origins (e.g., arrow points away this node)
    * `label`: the label of the flow to appear next to the line segment, typically an equation
    * `xstart`: the starting x position of the line segment
    * `ystart`: the starting y position of the line segment
    * `xend`: the ending x position of the line segment
    * `yend`: the ending y position of the line segment
    * `xmid`: the x midpoint of the line segment, for intersections with other segments due to interactions
    * `ymid`: the y midpoint of the line segment, for intersections with other segments due to interactions
1. `vertical_edges`: a data frame with 9 columns (same as `horizontal_edges`)
1. `curved_edges`: a data frame with 9 columns (same as `horizontal_edges`)
1. `feedback_edges`: a data frame with 9 columns (same as `horizontal_edges`)

The package attempts to make intelligent choices on which flows belong in which data frame.
For example, flows into or out of the system with only one node intersection are typically vertical.
And flows that bypass a node are typically curved.
The user may need to make modifications to suite their particular needs and style.

The data frames above are returned as a list.
In some cases, many of the data frames will be empty, as is this case in this example with a relatively simple model.

```{r make-dfs}
inputs <- make_diagram_inputs(mbmodel = mbsir)
diagram_dfs <- make_dataframes(input_list = inputs)
diagram_dfs
```

## Make the diagram

```{r make-diag, fig.width=6}
diagram_plot <- make_diagram(df_list = diagram_dfs)
diagram_plot
```

## Retrieve the ggplot2 code

In some cases, the user may want to work directly with the **ggplot2** code to make custom changes.
The `write_diagram_code` function does this.
The function has no arguments because the **ggplot2** is generic given the data frames input list.

```{r code}
gg_code <- write_diagram_code()
cat(gg_code)
```

The user can then copy this code and make changes as desired.
The code can also be simplified by deleting `geoms` that refer to empty data frames.
In this case, we just need the chunks of code that refer to the `nodes` and `horizontal_edges` data frames.
For example,

```{r custom, fig.width=6}
# load ggplot
library(ggplot2)

# unlist the data frames to individual objects
nodes <- diagram_dfs$nodes
horizontal_edges <- diagram_dfs$horizontal_edges
vertical_edges <- diagram_dfs$vertical_edges
curved_edges <- diagram_dfs$curved_edges
feedback_edges <- diagram_dfs$feedback_edges

# make blue boxes with white lettering
outplot <- ggplot() +
    geom_tile(data = nodes,
              aes(x = x, y = y),
              color = "white",  # CHANGED HERE
              fill = "blue",  # CHANGED HERE
              width = 1,
              height = 1) +
    geom_text(data = nodes,
              aes(x = x, y = y, label = label),
              size = 8,
              color = "white") +  # ADDED TEXT COLOR
    geom_segment(data = horizontal_edges,
                 aes(x = xstart+0.5, y = ystart, xend = xend-0.5, yend = yend),
                 arrow = arrow(length = unit(0.25,"cm"), type = "closed"),
                 arrow.fill = "black",
                 lineend = "round",
                 linejoin = "mitre") +
    geom_text(data = horizontal_edges,
              aes(x = xmid, y = ymid, label = label)) +
    geom_segment(data = vertical_edges,
                 aes(x = xstart, y = ystart-0.5, xend = xend, yend = yend+0.5),
                 arrow = arrow(length = unit(0.25,"cm"), type = "closed"),
                 arrow.fill = "black",
                 lineend = "round",
                 linejoin = "mitre") +
    geom_text(data = vertical_edges,
              aes(x = xmid+0.25, y = ymid, label = label)) +
    geom_curve(data = feedback_edges,
               ncp = 100,
               curvature = -2,
               aes(x = xstart-0.25, y = ystart+0.5, xend = xend+0.25, yend = yend+0.5),
               arrow = arrow(length = unit(0.25,"cm"), type = "closed"),
               arrow.fill = "black",
               lineend = "round") +
    geom_text(data = feedback_edges,
              aes(x = xmid, y = ymid+0.85, label = label)) +
    coord_equal(clip = "off") +
    theme_void()

  if(nrow(curved_edges) > 0) {
    outplot <- outplot +
      lapply(split(curved_edges, 1:nrow(curved_edges)), function(dat) {
        geom_curve(data = dat, aes(x = xstart,
                                   y = ystart,
                                   xend = xend,
                                   yend = yend),
                   color = "red",  ## ADDED RED COLOR HERE  
                   linetype = as.numeric(dat["interaction"]) + 1,
                   curvature = dat["curvature"],
                   arrow = arrow(length = unit(0.25,"cm"), type = "closed"),
                   arrow.fill = "red",  ## MADE ARROW RED HERE
                   lineend = "round") }
      ) +
      geom_text(data = curved_edges,
                aes(x = labelx, y = labely, label = label))
  }

outplot
```

# More examples

## SIR with demography and waning immunity

Here is an example using a more complicated model, an SIR model with waning immunity.
This model includes demography (births and deaths) and cross-node connections (waning goes from the recovered class to the susceptible class).
The model is stored as `mbseird` and comes with the package.

```{r sird, fig.width=8}
inputs <- make_diagram_inputs(mbmodel = mbsird)
dfs <- make_dataframes(inputs)
fig <- make_diagram(dfs)
fig
```

## SIR stratified by two hosts

```{r twohost, fig.height=5, fig.width=8}
inputs <- make_diagram_inputs(mbmodel = mbsirtwohost)
dfs <- make_dataframes(inputs)
fig <- make_diagram(dfs)
fig
```
